# IRC Server Project

## 프로젝트 설명
이 프로젝트는 C++98을 사용하여 IRC(Internet Relay Chat) 서버를 구현하는 것입니다. 이 서버는 여러 클라이언트가 동시에 접속하여 실시간으로 메시지를 주고받을 수 있도록 합니다. 프로젝트는 싱글톤 패턴, 커맨드 패턴, 팩토리 패턴 등의 디자인 패턴을 사용하여 구조화되었습니다.

## 파일 구조
```
project_root/
├── include/
│   ├── IRCServer.hpp
│   ├── Command.hpp
│   └── Client.hpp
├── source/
│   ├── main.cpp
│   ├── IRCServer.cpp
│   ├── Command.cpp
│   └── Client.cpp
├── Makefile
└── README.md
```

## 설치 및 빌드 방법

### 요구 사항
- c++ 컴파일러
- make

### 빌드
1. 프로젝트 루트 디렉토리에서 `make` 명령을 실행하여 프로젝트를 빌드합니다.
    ```sh
    make
    ```

2. 빌드가 완료되면 `ircserv` 실행 파일이 생성됩니다.

### 클린 빌드
1. `make clean` 명령을 실행하여 생성된 객체 파일과 실행 파일을 삭제합니다.
    ```sh
    make clean
    ```

2. 필요시 `make fclean` 명령을 실행하여 모든 빌드 파일을 삭제하고 완전한 클린 빌드를 수행합니다.
    ```sh
    make fclean
    ```

3. `make re` 명령을 실행하여 클린 빌드 후 다시 빌드합니다.
    ```sh
    make re
    ```

## 사용 방법
1. 서버를 실행합니다.
    ```sh
    ./ircserv <port> <password>
    ```

    - `<port>`: 서버가 수신할 포트 번호.
    - `<password>`: 클라이언트가 서버에 연결할 때 필요한 비밀번호.

2. 클라이언트가 서버에 연결하여 다양한 IRC 명령어를 사용할 수 있습니다.
    - 예: `NICK`, `USER`, `JOIN`, `PART`, `PRIVMSG`, `QUIT`

## 지원되는 명령어
### 클라이언트 명령어 (모든 사용자가 사용할 수 있는 명령어)
- `NICK <nickname>`: 클라이언트의 닉네임을 설정합니다.
- `USER <username> <hostname> <servername> <realname>`: 클라이언트의 사용자 정보를 설정합니다.
- `JOIN <channel>`: 지정된 채널에 참여합니다.
- `PART <channel>`: 지정된 채널에서 나갑니다.
- `PRIVMSG <recipient> :<message>`: 수신자에게 개인 메시지를 보냅니다. 수신자는 유저 또는 채널일 수 있습니다.
- `QUIT [<message>]`: 서버 연결을 종료합니다. 선택적으로 종료 메시지를 보낼 수 있습니다.
### 오퍼레이터 명령어 (관리자 권한이 필요한 명령어)
- `KICK <channel> <user> [<comment>]`: 지정된 채널에서 유저를 강퇴합니다. 선택적으로 강퇴 사유를 입력할 수 있습니다.
- `INVITE <nickname> <channel>`: 유저를 채널에 초대합니다.
- `TOPIC <channel> [<topic>]`: 채널의 주제를 설정하거나 조회합니다.
- `MODE <channel> <mode> [<params>]`: 채널의 모드를 설정합니다.

---

## 사용된 함수
### 함수 분류

IRC 서버 프로젝트에서 사용할 함수들을 용도에 따라 분류하면 다음과 같습니다:

#### 1. 소켓 관련 함수
이 함수들은 네트워크 소켓의 생성, 바인딩, 연결 및 수락을 담당합니다.

- **socket**: 네트워크 통신에 사용할 소켓을 생성합니다.
- **bind**: 소켓에 로컬 주소를 할당합니다.
- **listen**: 소켓을 수신 대기 상태로 만듭니다.
- **accept**: 대기 중인 연결을 수락합니다.
- **connect**: 소켓을 원격 호스트에 연결합니다.
- **setsockopt**: 소켓 옵션을 설정합니다.
- **getsockname**: 소켓의 로컬 주소를 가져옵니다.

#### 2. 데이터 전송 및 수신 함수
이 함수들은 소켓을 통해 데이터를 보내고 받는 역할을 합니다.

- **send**: 소켓을 통해 데이터를 보냅니다.
- **recv**: 소켓을 통해 데이터를 받습니다.
- **inet_addr**: IP 주소 문자열을 네트워크 바이트 순서의 32비트 주소로 변환합니다.
- **inet_ntoa**: 네트워크 바이트 순서의 32비트 주소를 IP 주소 문자열로 변환합니다.

#### 3. 주소 및 호스트 관련 함수
이 함수들은 네트워크 주소 및 호스트 정보를 다룹니다.

- **getprotobyname**: 프로토콜 이름으로 프로토콜 엔트리를 찾습니다.
- **gethostbyname**: 호스트 이름으로 호스트 엔트리를 찾습니다.
- **getaddrinfo**: 호스트 이름과 서비스 이름을 IP 주소와 포트 번호로 변환합니다.
- **freeaddrinfo**: getaddrinfo 함수로 할당된 메모리를 해제합니다.

#### 4. 바이트 순서 변환 함수
이 함수들은 바이트 순서를 변환합니다.

- **htons**: 호스트 바이트 순서에서 네트워크 바이트 순서로 16비트 값을 변환합니다.
- **htonl**: 호스트 바이트 순서에서 네트워크 바이트 순서로 32비트 값을 변환합니다.
- **ntohs**: 네트워크 바이트 순서에서 호스트 바이트 순서로 16비트 값을 변환합니다.
- **ntohl**: 네트워크 바이트 순서에서 호스트 바이트 순서로 32비트 값을 변환합니다.

#### 5. 멀티플렉싱 함수
이 함수들은 여러 파일 디스크립터의 상태를 동시에 검사하여 I/O 이벤트를 처리합니다.

- **poll**: 여러 파일 디스크립터의 이벤트를 모니터링합니다.
- **select**: 여러 파일 디스크립터의 이벤트를 모니터링합니다.
- **kqueue**: (FreeBSD, macOS) 여러 이벤트를 모니터링합니다.
- **epoll**: (Linux) 여러 파일 디스크립터의 이벤트를 모니터링합니다.

#### 6. 시스템 관련 함수
이 함수들은 시스템 레벨의 작업을 처리합니다.

- **close**: 파일 디스크립터를 닫습니다.
- **signal**: 신호 핸들러를 설정합니다.
- **sigaction**: 신호에 대한 동작을 정의합니다.
- **lseek**: 파일 내 위치를 설정합니다.
- **fstat**: 파일의 상태 정보를 얻습니다.
- **fcntl**: 파일 디스크립터의 동작을 변경합니다.
