01. 한글로 대답.
02. 목표는 과제 요구사항에 맞춰 소스코드 전문을 작성하는 것.
03. C++ 98에서 작성.
04. Makefile을 작성하면 안된다.
05. 클래스 이름은 UpperCamelCase을 따를 것.
06. 모든 출력은 개행으로 끝나고, 표준 출력을 이용할 것.
07. C언어의 특징적인 *printf(), *alloc() and free() 함수들을 사용 금지.
08. "using namespace <ns_name>", "friend" 사용 금지
09. Orthodox Canonical Form으로 클래스 작성.
10. 템플릿 함수를 제외하고 헤더 파일에는 함수의 구현만 있을 것.
11. 헤더가드를 항상 넣을 것.

이하 과제 요구사항

Files to turn in : Makefile, main.cpp, MutantStack.{h, hpp}

Now, time to move on more serious things. Let’s develop something weird.
The std::stack container is very nice. Unfortunately, it is one of the only STL Containers that is NOT iterable. That’s too bad.
But why would we accept this? Especially if we can take the liberty of butchering the
original stack to create missing features.
To repair this injustice, you have to make the std::stack container iterable.
Write a MutantStack class. It will be implemented in terms of a std::stack.
It will offer all its member functions, plus an additional feature: iterators.
Of course, you will write and turn in your own tests to ensure everything works as
expected.

* Find a test example below.
int main()
{
MutantStack<int> mstack;
mstack.push(5);
mstack.push(17);
std::cout << mstack.top() << std::endl;
mstack.pop();
std::cout << mstack.size() << std::endl;
mstack.push(3);
mstack.push(5);
mstack.push(737);
//[...]
mstack.push(0);
MutantStack<int>::iterator it = mstack.begin();
MutantStack<int>::iterator ite = mstack.end();
++it;
--it;
while (it != ite)
{
std::cout << *it << std::endl;
++it;
}
std::stack<int> s(mstack);
return 0;
}

If you run it a first time with your MutantStack, and a second time replacing the
MutantStack with, for example, a std::list, the two outputs should be the same. Of
course, when testing another container, update the code below with the corresponding
member functions (push() can become push_back()).